/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <common.h>
#include <system.h>

#include <rcc.h>
#include <gpio.h>
#include <usart.h>

#include <app.h>

uint32_t SystemCoreClock = 64000000UL;

void init_usart2_pins() {
    // Enable GPIOA clock (assuming USART2 TX on PA2 and RX on PA15)
    RCC->AHB2ENR |= RCC_AHB2ENR_GPIOAEN;

    // Configure PA2 as USART2_TX
    GPIOA->MODER &= ~(GPIO_MODER_MODE2); // Clear mode
    GPIOA->MODER |= GPIO_MODER_MODE2_1;  // Set to alternate function mode
    GPIOA->AFR[0] |= (7 << (2 * 4));     // AF7 for USART2_TX (PA2)

    // Configure PA15 as USART2_RX
    GPIOA->MODER &= ~(GPIO_MODER_MODE15); // Clear mode
    GPIOA->MODER |= GPIO_MODER_MODE15_1;  // Set to alternate function mode
    GPIOA->AFR[1] |= (7 << ((15 - 8) * 4)); // AF7 for USART2_RX (PA15)
}


int main( void )
{
	CLOCK CLOCK;

	CLOCK.setSystemClockTo64MHz( );

    // SysTick-Interrupt konfigurieren
    if (SysTick_Config(SystemCoreClock / (1000U / (uint32_t)1))) { // 1 ms Ticks
        // Handle error
        while (1);
    }

    // Initialize USART2 pins
    init_usart2_pins();

    // Enable USART2 clock
    RCC->APB1ENR1 |= RCC_APB1ENR1_USART2EN;

    // Initialize USART2
    USART usart2(USART::Usart2);
    usart2.setUsartState(USART::Disabled); // Disable USART before configuration
    usart2.set_baudrate(USART::BR_115200); // Set baudrate to 115200
    usart2.setWordLength(USART::Start1_Data8_StopN); // 8 data bits
    usart2.setStopBits(USART::StopBits1); // 1 stop bit
    usart2.setParityControl(USART::Disabled); // No parity
    usart2.setTransmitterState(USART::Enabled); // Enable transmitter
    usart2.setReceiverState(USART::Enabled); // Enable receiver
    usart2.setUsartState(USART::Enabled); // Enable USART


	GPIO led( GPIO::Port::PORTB, 3 ); // LED an PB0
	led.setMode( GPIO::Mode::OUTPUT );
	led.setPull( GPIO::Pull::NO_PULL );
	led.setSpeed( GPIO::Speed::VERY_HIGH );

	while( 1 )
	{
	    // Transmit "Hello World" string
	    usart2.tx_str("Hello World");

		led.write( true );  // LED an
		delay_ms( 500 );
		led.write( false ); // LED aus
		delay_ms( 500 );
	}

	return 0;
}
